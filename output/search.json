[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "metaSurvey",
    "section": "",
    "text": "Descripci√≥n del proyecto\nmetaSurvey adem√°s de formar parte de mi trabajo final de grado en Estad√≠stica tiene varias motivaciones en el medio, entre ellas el objetivo personal de poder contribuir en el desarrollo de paquetes de la comunidad R, ilusi√≥n que tengo desde que curs√© en plena pandemia Nuevas Tecnolog√≠as para el An√°lisis de Datos con Natalia, mi actual tutora y curso donde tuve la oportunidad de ser ayudante en su nueva versi√≥n Ciencia de datos con R torturando y trasmitiendo a los alumnos sobre el uso de R en diversos campos cercanos a la estad√≠stica. La creaci√≥n de un paquete en R no fue ni es una tarea sencilla, si bien existen diferentes herramientas y paquetes para hacer la vida de los desarrolladores mas facil, el gran problema es poder encontrar una idea, motivaci√≥n y tiempo para poder realizarlo. El sue√±o de tener un paquete era facil de so√±ar pero dificil de encontrar una idea original y a√∫n mas disponer del tiempo para hacerlo.\nEn noviembre de 2021 en mi trabajo como Analista de Datos en COGNUS se me ofreci√≥ formar parte del desarrollo de PRISMA un portal de la Agencia Nacional de Innovaci√≥n e Investigaci√≥n (ANII) donde mi tarea principal fue trabajar con datos provenientes de encuestas por muestreo para obtener diferentes indicadores publicados a lo largo del portal.\nEl portal tiene como objetivo ser un sitio que reuna informaci√≥n e indicadores de inter√©s para investigadores e emprendedores del pa√≠s, si bien una gran parte de la informaci√≥n es generada por la Agencia es importante tener un contexto econom√≠co del pa√≠s como puede ser indicadores de mercado de trabajo e ingresos de los hogares recurriendo a la fuente principal de informaci√≥n en este rubro, la Encuesta Continua de Hogares (ECH) del Instituto Nacional de Estad√≠stica de Uruguay (INE). Adem√°s de contar con esta informaci√≥n es relevante medir el impacto de ciertas politicas en la innovaci√≥n en nuestro pa√≠s y es por esto que se construyen indicadores provenientes de la Encuesta de Actividades de Innovaci√≥n (EAI)\nde la cual soy muy admirador llegando a que admirar cas√≠ de la misma forma que lo hago con artistas pop a los principales desarrolladores, como pueden ser Hadley Wickham,"
  },
  {
    "objectID": "chapters/chapter1.html#footnotes",
    "href": "chapters/chapter1.html#footnotes",
    "title": "1¬† Introducci√≥n",
    "section": "",
    "text": "Aqu√≠ puede verse el c√≥digo fuente de la funci√≥n get_flow del paquete tidycensus donde se puede en la linea 151 la recodificaci√≥n de variables se hace con una tabla mig_recodes y al explorar el contenido puede verse como se recodifican las variables adem√°s de que la funci√≥n tambi√©n tiene c√≥digo para manejar la forma de presentaci√≥n de los datos, manipulaci√≥n de datos geogr√°ficos y la estructura del objeto a devolver.‚Ü©Ô∏é"
  },
  {
    "objectID": "chapters/chapter2.html#desarrollo-de-paquetes-en-r",
    "href": "chapters/chapter2.html#desarrollo-de-paquetes-en-r",
    "title": "2¬† Marco conceptual",
    "section": "2.1 Desarrollo de paquetes en R",
    "text": "2.1 Desarrollo de paquetes en R\nR al ser un lenguaje de c√≥digo abierto y adem√°s cuenta con una gran comunidad de usuarios, en diferentes √°reas de investigaci√≥n, ha permitido que se desarrollen una gran cantidad de paquetes que permiten realizar diferentes tareas de an√°lisis de datos, visualizaci√≥n, modelado, entre otros. En este sentido, el desarrollo de paquetes en R es una tarea que se ha vuelto muy com√∫n entre los usuarios de R, ya que permite compartir c√≥digo, documentaci√≥n y datos de manera sencilla.\nPara cas√≠ cualquier disciplina cient√≠fica o en la industria se puede encontrar una comunidad de usuarios que desarollan paquetes en R, en este sentido, el desarrollo de paquetes en R es una tarea que se ha vuelto muy com√∫n entre los usuarios de R y es muy sencillo de realizar. A continuaci√≥n, se presentan los conceptos b√°sicos para el desarrollo de paquetes en R.\n\n2.1.1 ¬øPor qu√© desarrollar un paquete en R?\nDesarrollar un paquete en R tiene varias ventajas, entre las cuales se pueden mencionar las siguientes:\n\nReutilizaci√≥n de c√≥digo: Es importante tener en cuenta que existe una comunidad que hace cosas similares a las que uno hace, por lo que es posible que alguien ya haya escrito una funci√≥n que uno necesita. Por lo tanto, siempre es buena buscar si existe algun paquete que ya tenga las funcionalidades que se requieren.\nCompartir c√≥digo: La comunidad de R es muy activa y siempre est√° dispuesta a compartir c√≥digo, por esta raz√≥n es que se mantienen en constante desarrollo de paquetes.\nColaboraci√≥n: El trabajo colaborativo es esencial en el desarrollo de paquetes en R, ya que permite que diferentes personas puedan aportar con nuevas funcionalidades, correcciones de errores, entre otros.\n\n\n\n2.1.2 Elementos b√°sicos de un paquete en R\nPara que nuestro conjunto de funciones, datos y documentaci√≥n sea considerado un paquete en R, es necesario que cumpla con ciertos requisitos m√≠nimos. A continuaci√≥n, se presentan los componentes m√≠nimos que debe tener un paquete en R para ser publicado en CRAN.\n\nDirectorio: Un paquete en R debe estar contenido en un directorio que contenga al menos los siguientes archivos y directorios:\n\nR/: Directorio que contiene los archivos con las funciones que se desean incluir en el paquete.\nman/: Directorio que contiene los archivos con la documentaci√≥n de las funciones que se encuentran en el directorio R/. En general se utiliza Roxygen2 (Wickham et al., 2024) para generar la documentaci√≥n de las funciones.\nDESCRIPTION: Archivo que contiene la descripci√≥n del paquete, incluyendo el nombre, versi√≥n, descripci√≥n, autor, entre otros.\nNAMESPACE: Archivo que contiene la informaci√≥n sobre las funciones que se exportan y las dependencias del paquete.\nLICENSE: Archivo que contiene la licencia bajo la cual se distribuye el paquete.\nREADME.md: Archivo que contiene informaci√≥n general sobre el paquete.\n\nDocumentaci√≥n: La documentaci√≥n de las funciones es un componente esencial de un paquete en R, ya que permite que los usuarios puedan entender el funcionamiento de las funciones que se encuentran en el paquete. La documentaci√≥n de las funciones se realiza utilizando el sistema de documentaci√≥n de R, que se basa en el uso de comentarios en el c√≥digo fuente de las funciones.\nPruebas: Es importante que el paquete tenga pruebas que permitan verificar que las funciones se comportan de la manera esperada. Las pruebas se realizan utilizando el paquete testthat (Wickham, 2011) que permite realizar pruebas unitarias.\nControl de versiones: Es importante que el paquete tenga un sistema de control de versiones que permita llevar un registro de los cambios que se realizan en el paquete. El sistema de control de versiones m√°s utilizado en la comunidad de R es git.\nLicencia: Es importante que el paquete tenga una licencia que permita a los usuarios utilizar, modificar y distribuir el paquete. La licencia m√°s utilizada en la comunidad de R es la licencia MIT.\n\nEl proceso de subir un paquete a CRAN es un proceso que puede ser tedioso, ya que se deben cumplir con ciertos requisitos que son revisados por los mantenedores de CRAN, no es trivial y puede tomar tiempo, sin embargo, es un proceso que vale la pena ya que permite que el paquete sea utilizado por una gran cantidad de usuarios.\nEl proceso de chequeo fue automatizado con github actions, por lo que cada vez que se realiza un cambio en el repositorio, se ejecutan los chequeos de CRAN y se notifica si el paquete cumple con los requisitos para ser publicado en caso de que no cumpla con los requisitos se notifica el error y no puede ser incluido en la rama principal del repositorio hasta que se corrija el error.\nTodo el proceso y c√≥digo fuente del paquete se encuentra disponible en el repositorio de github del paquete. En el caso que este interesado en colaborar con el desarrollo del paquete puede consultar la gu√≠a de contribuci√≥n"
  },
  {
    "objectID": "chapters/chapter2.html#paradigmas-de-programaci√≥n-en-r",
    "href": "chapters/chapter2.html#paradigmas-de-programaci√≥n-en-r",
    "title": "2¬† Marco conceptual",
    "section": "2.2 Paradigmas de programaci√≥n en R",
    "text": "2.2 Paradigmas de programaci√≥n en R\nR es un lenguaje de programaci√≥n que permite realizar programaci√≥n funcional y orientada a objetos, lo que permite que los usuarios puedan utilizar diferentes paradigmas de programaci√≥n para resolver problemas. A continuaci√≥n, se presentan los conceptos b√°sicos de la programaci√≥n funcional y orientada a objetos en R.\n\n2.2.1 Programaci√≥n funcional\nLa programaci√≥n funcional es un paradigma de programaci√≥n que se basa en el uso de funciones para resolver problemas. En R, las funciones son objetos de primera clase, lo que significa que se pueden utilizar como argumentos de otras funciones, se pueden asignar a variables, entre otros (Wickham, 2019, pp. 204‚Äì281). A continuaci√≥n, se presentan los conceptos b√°sicos de la programaci√≥n funcional en R.\n\nFunciones de orden superior: En R, las funciones de orden superior son funciones que toman como argumento una o m√°s funciones y/o retornan una funci√≥n. Un ejemplo de una funci√≥n de orden superior en R es la funci√≥n lapply que toma como argumento una lista y una funci√≥n y retorna una lista con los resultados de aplicar la funci√≥n a cada elemento de la lista.\nFunciones an√≥nimas: En R, las funciones an√≥nimas son funciones que no tienen nombre y se crean utilizando la funci√≥n function. Un ejemplo de una funci√≥n an√≥nima en R es la funci√≥n function(x) x^2 que toma como argumento x y retorna x^2.\nFunciones puras: En R, las funciones puras son funciones que no tienen efectos secundarios y retornan el mismo resultado para los mismos argumentos. Un ejemplo de una funci√≥n pura en R es la funci√≥n sqrt que toma como argumento un n√∫mero y retorna la ra√≠z cuadrada de ese n√∫mero.\n\nEste paradigma de programaci√≥n es muy √∫til para realizar an√°lisis de datos, ya que permite que los usuarios puedan utilizar funciones para realizar operaciones sobre los datos de manera sencilla y eficiente, dentro de metaSurvey no existe una presencia fuerte de programaci√≥n funcional, sin embargo, se utilizan algunas funciones de orden superior para realizar operaciones sobre los datos.\n\n\n2.2.2 Programaci√≥n orientada a objetos\nLa programaci√≥n orientada a objetos es un paradigma de programaci√≥n que se basa en el uso de objetos para resolver problemas. En R, los objetos son instancias de clases que tienen atributos y m√©todos (Mailund, 2017; Wickham, 2019, pp. 285‚Äì370). A continuaci√≥n, se presentan los conceptos b√°sicos de la programaci√≥n orientada a objetos en R.\n\nClases y objetos: En R, las clases son plantillas que definen la estructura y el comportamiento de los objetos y los objetos son instancias de clases. En R, las clases se definen utilizando la funci√≥n setClass y los objetos se crean utilizando la funci√≥n new.\nAtributos y m√©todos: En R, los atributos son variables que almacenan informaci√≥n sobre el estado de un objeto y los m√©todos son funciones que permiten modificar el estado de un objeto. En R, los atributos se definen utilizando la funci√≥n setClass y los m√©todos se definen utilizando la funci√≥n setMethod.\n\nDentro de metaSurvey se utiliza la programaci√≥n orientada a objetos para definir las clases de los objetos que se utilizan para representar los datos de las encuestas mediante una creaci√≥n de una clase especifica llamada Survey que permite adem√°s de almacenar los datos de la encuesta a√±adir atributos y m√©todos que permiten realizar operaciones sobre los datos de manera sencilla y eficiente.\nDe forma similar se modelan las clases Step, Recipe y Workflow elementos cruciales en el ecosistema de metaSurvey donde se definen los pasos de preprocesamiento, recetas de preprocesamiento y flujos de trabajo respectivamente. En este caso particular se utiliza el paquete R6 (Chang, 2022) que permite definir clases de manera sencilla y eficiente adem√°s de permitir la herencia de clases y la definici√≥n de m√©todos y atributos de manera sencilla.\n\n\n2.2.3 Meta-programaci√≥n\nLa meta-programaci√≥n es un paradigma de programaci√≥n que se basa en el uso de c√≥digo para manipular c√≥digo (Thomas Mailund, 2017; Wickham, 2019, pp. 373‚Äì500) . En R, la meta-programaci√≥n se realiza utilizando el sistema de metaprogramaci√≥n de R que se basa en el uso de expresiones, llamadas y funciones. A continuaci√≥n, se presentan los conceptos b√°sicos de la meta-programaci√≥n en R.\n\nExpresiones: En R, las expresiones son objetos que representan c√≥digo y se crean utilizando la funci√≥n quote. Un ejemplo de una expresi√≥n en R es la expresi√≥n quote(x + y) que representa el c√≥digo x + y.\nLlamadas: En R, las llamadas son objetos que representan la aplicaci√≥n de una funci√≥n a sus argumentos y se crean utilizando la funci√≥n call. Un ejemplo de una llamada en R es la llamada call(\"sum\", 1, 2, 3) que representa la aplicaci√≥n de la funci√≥n sum a los argumentos 1, 2 y 3.\nFunciones: En R, las funciones son objetos que representan c√≥digo y se crean utilizando la funci√≥n function. Un ejemplo de una funci√≥n en R es la funci√≥n function(x, y) x + y que representa el c√≥digo x + y."
  },
  {
    "objectID": "chapters/chapter2.html#inferencia-en-muestreo-de-poblaciones-finitas",
    "href": "chapters/chapter2.html#inferencia-en-muestreo-de-poblaciones-finitas",
    "title": "2¬† Marco conceptual",
    "section": "2.3 Inferencia en muestreo de poblaciones finitas",
    "text": "2.3 Inferencia en muestreo de poblaciones finitas\nEl objetivo de esta secci√≥n es brindar un contexto b√°sico sobre encuestas por muestreo, para luego presentar diferentes m√©todos de estimaci√≥n de par√°metros poblacionales como la estimaci√≥n de totales, medias, proporciones y sus respectivos errores est√°ndar.\nEl elemento crucial en la Inferencia en muestreo de poblaciones finitas es que se asume que la poblaci√≥n es finita y la aleatoriedad proviene de la selecci√≥n de la muestra, por lo que es necesario considerar la probabilidad de selecci√≥n de cada muestra posible. Es com√∫n escuchar el t√©rmino dise√±o en el contexto de encuestas por muestreo, el dise√±o de muestreo es el mecanismo que se utiliza para seleccionar la muestra, existen diferentes tipos de dise√±os que se utilizan en la pr√°ctica, sin embargo nos enfocaremos en el proceso de construcci√≥n de ponderadores los cuales son fundamentales para realizar inferencia.\nSupongamos que estamos interesados en estimar el total de una variable de inter√©s \\(y\\) en una poblaci√≥n finita, es decir, el total poblacional \\(T_y = \\sum_{i=1}^{N} y_i\\), donde \\(y_i\\) es el valor de la variable de inter√©s para el individuo \\(i\\) de la poblaci√≥n y \\(N\\) es el tama√±o de la poblaci√≥n. Si se selecciona una muestra de \\(n\\) elementos de la poblaci√≥n, es posible estimar el total poblacional utilizando la siguiente f√≥rmula:\n\\[\n\\hat{T}_y = \\sum_{i=1}^{n} y_i\n\\]\nDonde \\(\\hat{T}_y\\) es el estimador del total poblacional, \\(y_i\\) es el valor de la variable de inter√©s para el individuo \\(i\\) de la muestra y \\(n\\) es el tama√±o de la muestra. Es importante tener en cuenta que el estimador del total poblacional depende del mecanismo de muestreo que se utilice, para esto debemos de mencionar la siguiente variable aleatoria:\nAsumiendo un dise√±o concreto es decir, fijada \\(p(s)\\) podemos definir la variable (aleatoria) de pertenencia a la muestra \\(s\\) como:\n\\[\nI_{k} = \\begin{cases} 1 & \\text{si el individuo } k \\text{ pertenece a la muestra } s \\\\ 0 & \\text{en otro caso} \\end{cases}\n\\]\nDe esta forma es posible calcular la probabilidad de que el indivudo \\(k\\) sea incluido en la muestra \\(s\\), es decir \\(\\pi_k = E(I_k) = P(I_k = 1)\\) ya que es una variable aleatoria del tipo Bernoulli con probabilidad de √©xito \\(\\pi_k\\). Por lo que es estimar calcular total poblacional de la siguiente forma:\n\\[\n\\hat{T}_y = \\sum_{k=1}^{n} y_k = \\sum_{k = 1}^{n}{y_{i} \\times I_{k}} = \\sum_{k = 1}^{N}{}\n\\]\nEste ultimo paso nos permite realizar el\nEs decir, si consideramos una poblaci√≥n de \\(N\\) elementos (donde \\(N\\) es finito y puede ser desconocido) y se selecciona una muestra \\(s\\) de \\(n\\) elementos. Cada individuo de la pobaci√≥n tiene una probabilidad de ser seleccionado en la muestra, dependiendo el mecanismo de muestreo que se utilice. Cada muestra de \\(n\\) elementos tiene una probabilidad de ser seleccionada la que denominaremos funci√≥n de dise√±o \\(p(s)\\), por lo que es posible asignar una probabilidad de selecci√≥n a cada individuo de la poblaci√≥n, es decir contar aquellas veces que un individuo fue seleccionado en todas las posibles muestras de \\(n\\) elementos, esto se conoce como probabilidad de inclusi√≥n de primer √≥rden.\nExisten dise√±os sencillos donde es facil obtener la probabilidad de selecci√≥n de cada individuo de la poblaci√≥n, como el muestreo aleatorio simple (SI), muestreo sistem√°tico (SY), muestreo estratificado, muestreo por conglomerados, entre otros. La utilizaci√≥n de uno u otro depende de la variable objetivo o grupo de variables que se desea estimar, aunque en la pr√°ctica se utilizan dise√±os complejos que combinan varios de estos dise√±os en varias etapas de selecci√≥n.\nUn ejemplo de este tipo de dise√±o puede ser la ECH donde se utiliza un muestreo aleatorio en dos etapas, donde en la primera etapa se seleccionan las unidades primarias de muestreo (UPM) correspondientes a conglomerados de manzanas (zonas censales). En la segunda etapa se seleccionan las unidades secundarias de muestreo (USM) correspondientes a viviendas dentro de las manzanas seleccionadas. Luego, se identifican los hogares seleccionados y los individuos que los componen son seleccionados en su totalidad para ser encuestados (Instituto Nacional de Estadƒ±ÃÅstica, 2021).\n\n2.3.1 Ejemplo Dise√±o Simple con remplazo\nConsiderando una poblaci√≥n de \\(N\\) elementos existen \\(\\binom{N}{n}\\) maneras de seleccionar una muestra de \\(n\\) elementos, por lo que la probabilidad de seleccionar una muestra \\(s\\) de \\(n\\) elementos es:\n\\[\nP(S = s) = p(s) = 1 / \\binom{N}{n}\n\\]\nUna vez definida la funci√≥n de dise√±o, es posible definir las probabilidades de inclusi√≥n de primer √≥rden, es decir la probabilidad de que un individuo de la poblaci√≥n sea seleccionado en la muestra, esta probabilidad se denota como \\(\\pi_i\\) y se define como para el caso SI.\nSi miramos a un individuo de la poblaci√≥n, este puede ser seleccionado en la muestra si y solo si se encuentra en la muestra \\(s\\), por lo que debemos de contar cuantas formas diferentes podemos seleccionar \\(n-1\\) elementos de los \\(N-1\\) restantes, por lo que la probabilidad de inclusi√≥n de primer √≥rden es, es decir \\(\\binom{N-1}{n-1}\\), por lo que la probabilidad de inclusi√≥n de primer √≥rden es:\n\\[\n\\pi_i = \\frac{\\binom{N-1}{n-1}}{\\binom{N}{n}} = \\frac{n}{N}\n\\]\nUna vez definida la probabilidad de inclusi√≥n de primer √≥rden\n\n\n\n\nChang, W. (2022). R6: Encapsulated classes with reference semantics.\n\n\nInstituto Nacional de Estadƒ±ÃÅstica. (2021). Metodologƒ±ÃÅa de la Encuesta Continua de Hogares Instituto Nacional de Estadƒ±ÃÅstica. https://www.ine.gub.uy\n\n\nMailund, T. (2017). Advanced object-oriented programming in r: Statistical programming for data science, analysis and finance. SPRINGER.\n\n\nThomas Mailund. (2017). Metaprogramming in r (1st ed.). Apress. https://www.amazon.com/Metaprogramming-Advanced-Statistical-Programming-Analysis/dp/1484228804\n\n\nWickham, H. (2011). Testthat: Get started with testing. The R Journal, 3, 510. https://journal.r-project.org/archive/2011-1/RJournal_2011-1_Wickham.pdf\n\n\nWickham, H. (2019). Advanced r, second edition. CRC Press.\n\n\nWickham, H., Danenberg, P., Cs√°rdi, G., & Eugster, M. (2024). roxygen2: In-Line Documentation for R. https://roxygen2.r-lib.org/"
  },
  {
    "objectID": "chapters/chapter5.html#ech",
    "href": "chapters/chapter5.html#ech",
    "title": "5¬† Resultados",
    "section": "5.1 ECH",
    "text": "5.1 ECH\n\nlibrary(magrittr)\n\nmetaSurvey::set_engine(\"data.table\")\n\nEngine: data.table\n\nech_meta = metaSurvey::load_survey(\n  path = metaSurvey::load_survey_example(\"ech_2018.csv\"),\n  svy_type = \"ech\",\n  svy_edition = \"2018\",\n  svy_weight = \"pesoano\"\n)\n\nech_meta_steps = ech_meta %&gt;%\n  metaSurvey::step_recode(\n    \"pea\",\n    pobpcoac %in% 2:5 ~ 1,\n    .default = 0\n  ) %&gt;%\n  metaSurvey::step_recode(\n    \"pet\",\n    pobpcoac != 1 ~ 1,\n    .default = 0\n  ) %&gt;%\n  metaSurvey::step_recode(\n    \"po\",\n    pobpcoac == 2 ~ 1,\n    .default = 0\n  ) %&gt;%\n  metaSurvey::step_recode(\n    \"pd\",\n    pobpcoac %in% 3:5 ~ 1,\n    .default = 0\n  )\n\n\nmetaSurvey::view_graph(ech_meta_steps)"
  },
  {
    "objectID": "chapters/chapter5.html#eaii",
    "href": "chapters/chapter5.html#eaii",
    "title": "5¬† Resultados",
    "section": "5.2 EAII",
    "text": "5.2 EAII\n\nsvy_example = metaSurvey::load_survey(\n    svy_type = \"eaii\",\n    svy_edition = \"2019-2021\",\n    svy_weight = \"w_trans\",\n    input = metaSurvey::load_survey_example(\"2019-2021.csv\"),\n    dec = \",\"\n)\n\n# as.data.frame(svy_example)\n# as.tibble(svy_example)\n\nnew_svy = svy_example %&gt;%\n    metaSurvey::step_recode(\n        new_var = \"realiza_innovacion\",\n        B1_1_1 == 1 ~ 1,\n        B1_2_1 == 1 ~ 1,\n        B1_3_1 == 1 ~ 1,\n        B1_4_1 == 1 ~ 1,\n        B1_5_1 == 1 ~ 1,\n        B1_6_1 == 1 ~ 1,\n        B1_7_1 == 1 ~ 1,\n        B1_8_1 == 1 ~ 1,\n        B1_9_1 == 1 ~ 1,\n        .default = 0\n    ) %&gt;%\n    metaSurvey::step_recode(\n        new_var = \"sector\",\n        data.table::between(Division, 10, 33) ~ \"Industria\",\n        data.table::between(Division, 34, 99) ~ \"Servicios\",\n        Division == \"C1\" ~ \"Industria\",\n        Division == \"C2\" ~ \"Servicios\",\n        Division == \"E1\" ~ \"Servicios\"\n    ) %&gt;%\n    metaSurvey::step_recode(\n        new_var = \"innovativa\",\n        E1_1_1 == 1 ~ 1,\n        E1_2_1 == 1 ~ 1,\n        .default = 0\n    ) %&gt;%\n    metaSurvey::step_recode(\n        new_var = \"tipo_actividad\",\n        B1_1_1 == 1 ~ \"I + D Interna\",\n        B1_2_1 == 1 ~ \"I + D Externa\",\n        B1_3_1 == 1 ~ \"Bienes de Capital\",\n        B1_4_1 == 1 ~ \"Software\",\n        B1_5_1 == 1 ~ \"Propiedad Intelectual\",\n        B1_6_1 == 1 ~ \"Ingenier√≠a\",\n        B1_7_1 == 1 ~ \"Capacitaci√≥n\",\n        B1_8_1 == 1 ~ \"Marketing\",\n        B1_9_1 == 1 ~ \"Gesti√≥n\",\n        .default = \"Otra\"\n    ) %&gt;%\n    metaSurvey::step_recode(\n        new_var = \"tipo_innovacion\",\n        E1_1_1 == 1 ~ \"Producto\",\n        E1_2_1 == 1 ~ \"Proceso\",\n        .default = \"Otra\"\n    ) %&gt;%\n    metaSurvey::step_recode(\n        new_var = \"cant_traba_tramo\",\n        data.table::between(IG_4_1_3, 0, 4) ~ \"1\",\n        data.table::between(IG_4_1_3, 5, 19) ~ \"2\",\n        data.table::between(IG_4_1_3, 20, 99) ~ \"3\",\n        IG_4_1_3 &gt; 99 ~ \"4\"\n    ) %&gt;%\n    metaSurvey::step_recode(\n        new_var = \"ingreso_vta_pesos\",\n        data.table::between(IG_5_1_1_3, 0, 9942787) ~ \"1\",\n        data.table::between(IG_5_1_1_3, 9942788, 49713934) ~ \"2\", # nolint\n        data.table::between(IG_5_1_1_3, 49713935, 372854507) ~ \"3\", # nolint\n        IG_5_1_1_3 &gt; 372854507 ~ \"4\"\n    ) %&gt;%\n    metaSurvey::step_recode(\n        new_var = \"tamanio\",\n        cant_traba_tramo == \"1\" & ingreso_vta_pesos == \"1\" ~ \"Pequenias\",\n        cant_traba_tramo == \"2\" & ingreso_vta_pesos == \"2\" ~ \"Pequenias\",\n        cant_traba_tramo == \"2\" & ingreso_vta_pesos == \"1\" ~ \"Pequenias\",\n        cant_traba_tramo == \"1\" & ingreso_vta_pesos == \"2\" ~ \"Pequenias\",\n        cant_traba_tramo == \"3\" & ingreso_vta_pesos == \"3\" ~ \"Medianas\",\n        cant_traba_tramo == \"3\" & ingreso_vta_pesos == \"2\" ~ \"Medianas\",\n        cant_traba_tramo == \"3\" & ingreso_vta_pesos == \"1\" ~ \"Medianas\",\n        cant_traba_tramo == \"1\" & ingreso_vta_pesos == \"3\" ~ \"Medianas\",\n        cant_traba_tramo == \"2\" & ingreso_vta_pesos == \"3\" ~ \"Medianas\",\n        cant_traba_tramo == \"4\" & ingreso_vta_pesos == \"4\" ~ \"Grandes\",\n        cant_traba_tramo == \"4\" & ingreso_vta_pesos == \"3\" ~ \"Grandes\",\n        cant_traba_tramo == \"4\" & ingreso_vta_pesos == \"2\" ~ \"Grandes\",\n        cant_traba_tramo == \"4\" & ingreso_vta_pesos == \"1\" ~ \"Grandes\",\n        cant_traba_tramo == \"1\" & ingreso_vta_pesos == \"4\" ~ \"Grandes\",\n        cant_traba_tramo == \"2\" & ingreso_vta_pesos == \"4\" ~ \"Grandes\",\n        cant_traba_tramo == \"3\" & ingreso_vta_pesos == \"4\" ~ \"Grandes\"\n    ) %&gt;%\n    metaSurvey::step_compute(\n        subsector = Division\n    )\n\nmetaSurvey::get_metadata(new_svy)\n\n‚ÑπÔ∏è  Type: eaii\nüíπ Edition: 2019-2021\nüñ•Ô∏è  Engine: data.table\nüßÆ Weight: w_trans\nüîç Steps: \n  - New group: realiza_innovacion\n  - New group: sector\n  - New group: innovativa\n  - New group: tipo_actividad\n  - New group: tipo_innovacion\n  - New group: cant_traba_tramo\n  - New group: ingreso_vta_pesos\n  - New group: tamanio\n  - New variable: subsector\n\n\n\nmetaSurvey::view_graph(new_svy)"
  },
  {
    "objectID": "chapters/chapter5.html#eph",
    "href": "chapters/chapter5.html#eph",
    "title": "5¬† Resultados",
    "section": "5.3 EPH",
    "text": "5.3 EPH\n\nph2022_3 = metaSurvey::load_survey(\n  path = metaSurvey::load_survey_example(\"eph2022_3.csv\"),\n  svy_type = \"eph\",\n  svy_edition = \"2022_3\",\n  svy_weight = \"PONDERA\"\n) %&gt;% \n  metaSurvey::step_recode(\n    \"pea\",\n    ESTADO %in% 1:2 ~ 1,\n    .default = 0\n  ) %&gt;% \n  metaSurvey::step_recode(\n    \"pet\",\n    ESTADO != 4 ~ 1,\n    .default = 0\n  ) %&gt;% \n  metaSurvey::step_recode(\n    \"po\",\n    ESTADO == 1 ~ 1,\n    .default = 0\n  ) %&gt;% \n  metaSurvey::step_recode(\n    \"pd\",\n    ESTADO == 2 ~ 1,\n    .default = 0\n  )\n\n\nmetaSurvey::view_graph(ph2022_3)"
  },
  {
    "objectID": "chapters/chapter6.html",
    "href": "chapters/chapter6.html",
    "title": "6¬† Infraestructura",
    "section": "",
    "text": "Infra\nDocker\nKubernetes\nTests\nEnv√≠o a CRAN"
  }
]