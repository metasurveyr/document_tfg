<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>2&nbsp; Marco teórico – metasurvey</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../chapters/chapter3.html" rel="next">
<link href="../chapters/chapter1.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-6acfec930f039e47772079a424c7233b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Sin resultados",
    "search-matching-documents-text": "documentos encontrados",
    "search-copy-link-title": "Copiar el enlace en la búsqueda",
    "search-hide-matches-text": "Ocultar resultados adicionales",
    "search-more-match-text": "resultado adicional en este documento",
    "search-more-matches-text": "resultados adicionales en este documento",
    "search-clear-button-title": "Borrar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Buscar"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapters/chapter2.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Marco teórico</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Buscar" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">metasurvey</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/metaSurveyR/metasurvey" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="../metasurvey.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Alternar modo lector">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Buscar"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Descripción del proyecto</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/chapter1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introducción</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/chapter2.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Marco teórico</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/chapter3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Métodos computacionales</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/chapter4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Antecedentes</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/chapter5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Metodología y desarrollo</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/chapter6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Casos de uso</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/chapter7.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Pasos a futuro</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/bibliography.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Biblografía</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Alternar sección">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Appendices/AppendixA.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Apendice</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Tabla de contenidos</h2>
   
  <ul>
  <li><a href="#inferencia-en-muestreo-de-poblaciones-finitas" id="toc-inferencia-en-muestreo-de-poblaciones-finitas" class="nav-link active" data-scroll-target="#inferencia-en-muestreo-de-poblaciones-finitas"><span class="header-section-number">2.1</span> Inferencia en muestreo de poblaciones finitas</a>
  <ul class="collapse">
  <li><a href="#diseño-muestral" id="toc-diseño-muestral" class="nav-link" data-scroll-target="#diseño-muestral"><span class="header-section-number">2.1.1</span> Diseño muestral</a></li>
  <li><a href="#sec-ht" id="toc-sec-ht" class="nav-link" data-scroll-target="#sec-ht"><span class="header-section-number">2.1.2</span> Probabilidades de Inclusión y el Estimador de Horvitz-Thompson</a></li>
  <li><a href="#ponderación-basada-en-el-diseño-y-estimadores-más-comunes" id="toc-ponderación-basada-en-el-diseño-y-estimadores-más-comunes" class="nav-link" data-scroll-target="#ponderación-basada-en-el-diseño-y-estimadores-más-comunes"><span class="header-section-number">2.1.3</span> Ponderación basada en el diseño y estimadores más comunes</a></li>
  <li><a href="#medidas-de-incertidumbre-y-errores-estándar" id="toc-medidas-de-incertidumbre-y-errores-estándar" class="nav-link" data-scroll-target="#medidas-de-incertidumbre-y-errores-estándar"><span class="header-section-number">2.1.4</span> Medidas de incertidumbre y errores estándar</a></li>
  <li><a href="#métodos-de-remuestreo" id="toc-métodos-de-remuestreo" class="nav-link" data-scroll-target="#métodos-de-remuestreo"><span class="header-section-number">2.1.5</span> Métodos de remuestreo</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/metaSurveyR/metasurvey/edit/main/chapters/chapter2.qmd" class="toc-action"><i class="bi bi-github"></i>Editar esta página</a></li><li><a href="https://github.com/metaSurveyR/metasurvey/blob/main/chapters/chapter2.qmd" class="toc-action"><i class="bi empty"></i>Ver el código</a></li><li><a href="https://github.com/metaSurveyR/metasurvey/issues/new" class="toc-action"><i class="bi empty"></i>Informar de un problema</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-Chapter2" class="quarto-section-identifier"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Marco teórico</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="cell">
<style type="text/css">
p {
  text-align: justify
}
</style>
</div>
<p>Este capítulo desarrolla el fundamento teórico esencial para la comprensión de la inferencia estadística en el contexto de muestreo de poblaciones finitas, un pilar fundamental en la generación de indicadores sociales y estadística oficial. Se presenta una progresión sistemática y rigurosa desde los conceptos fundamentales hasta las técnicas más sofisticadas de estimación de varianza, con especial énfasis en su aplicación práctica en encuestas socioeconómicas complejas.</p>
<p>El marco teórico se estructura en tres componentes principales interrelacionados:</p>
<ol type="1">
<li>La teoría fundamental de inferencia en muestreo, incluyendo los principios probabilísticos subyacentes</li>
<li>Los métodos de estimación de parámetros poblacionales y sus propiedades estadísticas asintóticas</li>
<li>Las técnicas específicas para el tratamiento de diseños muestrales complejos y sus implicaciones metodológicas</li>
</ol>
<p>Esta base teórica rigurosa resulta fundamental no solo para comprender la implementación de los métodos de estimación de varianza en el paquete <code>metasurvey</code>, sino también para garantizar la validez estadística y robustez de las inferencias realizadas.</p>
<section id="inferencia-en-muestreo-de-poblaciones-finitas" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="inferencia-en-muestreo-de-poblaciones-finitas"><span class="header-section-number">2.1</span> Inferencia en muestreo de poblaciones finitas</h2>
<p>Las encuestas por muestreo constituyen el pilar metodológico para la construcción de indicadores socio-demográficos y económicos en la estadística oficial contemporánea. La inferencia en este contexto demanda no solo estimaciones puntuales precisas, sino también una cuantificación rigurosa de su variabilidad e incertidumbre asociada, elementos esenciales para establecer la confiabilidad y validez de las estimaciones y permitir una inferencia estadística robusta fundamentada en principios matemáticos sólidos.</p>
<section id="diseño-muestral" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="diseño-muestral"><span class="header-section-number">2.1.1</span> Diseño muestral</h3>
<p>El diseño muestral representa la piedra angular del proceso inferencial en poblaciones finitas, constituyendo el mecanismo probabilístico que determina la selección de unidades muestrales y, consecuentemente, las propiedades estadísticas fundamentales de los estimadores derivados.</p>
<p>La definición matemática se basa en que dado un universo <span class="math inline">\(U\)</span> de <span class="math inline">\(N\)</span> elementos (puede ser conocido o no) <span class="math inline">\(\{u_{1},u_{2}, \cdots, u_{N}\}\)</span> y se considera un conjunto de tamaño <span class="math inline">\(n\)</span> de elementos de <span class="math inline">\(U\)</span> que se denota como <span class="math inline">\(s = \{u_{1},u_{2}, \cdots, u_{n}\}\)</span> al cual comúnmente denominamos <strong>muestra</strong>, el diseño muestral puede definirse de la siguiente forma:</p>
<p><span class="math display">\[
Pr(S = s) = p(s)
\]</span></p>
<p>Realizando un poco de inspección en la definición anterior se puede observar que el diseño muestral es una función de probabilidad que asigna una probabilidad a cada subconjunto de <span class="math inline">\(U\)</span> de tamaño <span class="math inline">\(n\)</span>. En este sentido, es posible definir diferentes tipos de diseño, entre ellos los más comunes:.</p>
<ul>
<li><strong>Diseño Aleatorio Simple (SI)</strong></li>
</ul>
<p>El diseño aleatorio simple es el diseño más sencillo y se define de la siguiente forma:</p>
<p><span class="math display">\[
p(s) = \frac{1}{\binom{N}{n}}
\]</span></p>
<p><em>Ejemplo</em>: Si se tiene una población de 1000 individuos y se desea seleccionar una muestra de 100 de manera aleatoria, cada combinación de 100 individuos tiene la misma probabilidad de ser seleccionada.</p>
<ul>
<li><strong>Diseño Bernoulli (BE)</strong></li>
</ul>
<p>El (<strong>BE</strong>) es un diseño sencillo que se utiliza cuando se desea seleccionar una muestra de un universo de tamaño <span class="math inline">\(N\)</span> además de considerar una probabilidad de inclusión <span class="math inline">\(\pi\)</span> para cada elemento de <span class="math inline">\(U\)</span>. Se define el diseño Bernoulli de la siguiente forma:</p>
<p><span class="math display">\[
p(s) = \underbrace{\pi \times \pi \times \cdots \times \pi}_{n_{s}} \times \underbrace{(1-\pi) \times (1-\pi) \times \cdots \times (1-\pi)}_{N-n_{s}} = \pi ^{n_{s}} (1-\pi)^{N-n_{s}}
\]</span></p>
<p>Una diferencia fundamental entre el diseño (<em>BE</em>) y el diseño <strong>SI</strong> es que en el <strong>BE</strong> el tamaño de muestra es aleatorio y su distribución es binomial, mientras que en el diseño SI el tamaño de muestra es fijo.</p>
<ul>
<li><strong>Diseño Estratificado (ST)</strong></li>
</ul>
<p>El diseño estratificado es un diseño que se utiliza cuando se desea seleccionar una muestra de tamaño <span class="math inline">\(n\)</span> de un universo de tamaño <span class="math inline">\(N\)</span> donde además se quiere dividir el universo en <span class="math inline">\(H\)</span> estratos <span class="math inline">\(U_{1}, U_{2}, \cdots, U_{H}\)</span>. Dentro de cada estrato se selecciona una muestra de tamaño <span class="math inline">\(n_{h}\)</span> y se define el diseño estratificado de la siguiente forma:</p>
<p><span class="math display">\[
p(s) = \prod_{l=1}^{H} p(s_{H})
\]</span></p>
<p>En cada estrato se puede utilizar un diseño diferente pero en general se utiliza el diseño <strong>SI</strong>, más conocido <strong>STSI</strong> (Stratified Simple Random Sampling). En este caso cada <span class="math inline">\(p_{h}(s_{h})\)</span> es el diseño aleatorio simple en el estrato <span class="math inline">\(h\)</span>.</p>
</section>
<section id="sec-ht" class="level3" data-number="2.1.2">
<h3 data-number="2.1.2" class="anchored" data-anchor-id="sec-ht"><span class="header-section-number">2.1.2</span> Probabilidades de Inclusión y el Estimador de Horvitz-Thompson</h3>
<p>Una vez definido el concepto de diseño muestral es posible definir la probabilidad de que un elemento de la población sea seleccionado en la muestra, esta probabilidad se conoce como probabilidad de inclusión y se define de la siguiente forma:</p>
<ul>
<li><strong>Probabilidad de inclusión de primer orden</strong></li>
</ul>
<p><span class="math display">\[
\pi_{k} = Pr(u_{k} \in s) = Pr(I_{k} = 1)
\]</span></p>
<p>Donde <span class="math inline">\(I_{k}\)</span> es una variable aleatoria que toma el valor de 1 si el elemento <span class="math inline">\(u_{k}\)</span> es seleccionado en la muestra y 0 en caso contrario. Definir estas variables indicadoras son de utilidad para entender el comportamiento de los estimadores bajo el diseño muestral y nos permite definir los estimadores en <span class="math inline">\(U\)</span> y no en <span class="math inline">\(S\)</span>. Es claro que <span class="math inline">\(I_{k} \sim Bernoulli(\pi_{k})\)</span> y <span class="math inline">\(E(I_{k}) = Pr(I_{k}) = \pi_{k}\)</span>.</p>
<p>Esta probabilidad es importante ya que es la la base para la construcción de estimadores insesgados y eficientes, en este sentido, es posible definir el estimador de Horvitz-Thompson (<strong>HT</strong>) para estimar un total <span class="math inline">\(t = \sum_{U} {t_{k}}\)</span> de la siguiente forma:</p>
<p><span class="math display">\[
\hat{t}_{y} = \sum_{k=1}^{N} \frac{y_{k}}{\pi_{k}} \times I_{k}
\]</span></p>
<p>Este estimador es propuesto por Horvitz y Thompson en 1952 y es un estimador insesgado en el diseño, en el sentido de que <span class="math inline">\(E(\hat{t}_{y}) = t\)</span> y es eficiente en el sentido de que <span class="math inline">\(Var(\hat{t}_{y})\)</span> es el menor posible entre los estimadores insesgados. Este estimador es muy utilizado en la práctica y es la base para la construcción de otros estadísticos, como medias, proporciones, varianzas, entre otros. Para más detalles sobre las propiedades de Horvitz-Thompson (<strong>HT</strong>) se puede consultar en <span class="citation" data-cites="särndal2003">(<a href="bibliography.html#ref-särndal2003" role="doc-biblioref">Särndal, Swensson, y Wretman 2003</a>)</span> y <span class="citation" data-cites="horvitz1952">(<a href="bibliography.html#ref-horvitz1952" role="doc-biblioref">Horvitz y Thompson 1952</a>)</span>.</p>
</section>
<section id="ponderación-basada-en-el-diseño-y-estimadores-más-comunes" class="level3" data-number="2.1.3">
<h3 data-number="2.1.3" class="anchored" data-anchor-id="ponderación-basada-en-el-diseño-y-estimadores-más-comunes"><span class="header-section-number">2.1.3</span> Ponderación basada en el diseño y estimadores más comunes</h3>
<p>En general es utilizado el concepto de ponderador para realizar estimaciones de totales, medias, proporciones, varianzas, entre otros. En este sentido, es posible definir el ponderador inducido por el diseño muestral de la siguiente forma:</p>
<p><span class="math display">\[
w_{k} = \frac{1}{\pi_{k}}
\]</span></p>
<p>Este ponderador puede interpretarse como el número individuos que representa el individuo <span class="math inline">\(k\)</span> en la población. Este valor es el que comúnmente se publica junto a los microdatos y el estándar en los diferentes softwares para procesar encuestas. Junto al estimador de un total es posible definir el estimador de un promedio, proporción o razón en el contexto de la <span class="math inline">\(\pi\)</span>-expansión.</p>
<section id="estimador-de-un-promedio" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="estimador-de-un-promedio">Estimador de un promedio</h4>
<p><span class="math display">\[
\hat{\bar{y}} = \frac{\sum_{k=1}^{N} w_{k} I_{k} y_{k}}{\sum_{k=1}^{N} w_{k} I_{k}}
\]</span></p>
<p>Este estimador puede ser utilizados en encuestas de hogares, donde se desea estimar el ingreso promedio de los hogares de una región de forma anual, o mensual.</p>
</section>
<section id="estimador-de-una-proporción" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="estimador-de-una-proporción">Estimador de una proporción</h4>
<p><span class="math display">\[
\hat{p} = \frac{\sum_{k=1}^{N} I_{k} w_{k} y_{k}}{\sum_{k=1}^{N} w_{k} I_{k}} = \frac{\sum_{k=1}^{N} I_{k} w_{k} y_{k}}{\hat{N}}
\]</span></p>
<p>Puede ser de interés estimar la proporción de hogares que tienen acceso a internet en una región, en este caso se puede utilizar el estimador de proporción.</p>
</section>
<section id="estimador-de-una-razón" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="estimador-de-una-razón">Estimador de una razón</h4>
<p>Se quiere estimar la razón <span class="math inline">\(R = \frac{\sum_{k=1}^{N} y_{k}}{\sum_{k=1}^{N} z_{k}}\)</span>. Siendo <span class="math inline">\(z_{k}\)</span> otra variable dentro del conjunto de datos. En este caso se puede definir el estimador de la razón de la siguiente forma:</p>
<p><span class="math display">\[
\hat{R} = \frac{\sum_{k=1}^{N} w_{k} y_{k}}{\sum_{k=1}^{N} w_{k}z_{k}}
\]</span></p>
<p>El estimador de razón es utilizado para construir variables de mercado de trabajo como la tasa de desempleo, tasa de ocupación, entre otros.</p>
</section>
<section id="inferencia-sobre-el-tamaño-de-la-población" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="inferencia-sobre-el-tamaño-de-la-población">Inferencia sobre el tamaño de la población</h4>
<p>Una vez definidos los estimadores, podemos ver que los estimadores de medias y proporciones son un caso particular del estimador de razón. Un detalle no menor es que asumimos <span class="math inline">\(N\)</span> fijo pero desconocido, por esto al realizar proporciones se ajusta el total sobre un estimador del tamaño de la población:</p>
<p><span class="math display">\[
\hat{N} = \sum_{k=1}^{N} I_{k}w_{k}
\]</span></p>
<p>Existen diseños denominados <strong>auto-ponderados</strong> donde por definición <span class="math inline">\(\sum_{k=1}^{N} w_{k} = N\)</span>, en este caso particular el estimador de medidas y proporciones es un caso particular del estimador de total, ya que el estadístico puede definirse de la siguiente forma:</p>
<p><span class="math display">\[
\hat{\bar{y}}_{s} = \frac{\sum_{k=1}^{N} I_{k} w_{k} y_{k}}{\sum_{k=1}^{N} w_{k} I_{k}} = \frac{\sum_{k=1}^{N} I_{k} w_{k} y_{k}}{N} = \frac{1}{N} \times \sum_{k=1}^{N} I_{k} w_{k} y_{k} = a \times \hat{t}_{y}
\]</span></p>
</section>
</section>
<section id="medidas-de-incertidumbre-y-errores-estándar" class="level3" data-number="2.1.4">
<h3 data-number="2.1.4" class="anchored" data-anchor-id="medidas-de-incertidumbre-y-errores-estándar"><span class="header-section-number">2.1.4</span> Medidas de incertidumbre y errores estándar</h3>
<p>Se puede medir la variabilidad de los estimadores y calcular su varianza. Para detalles completos de los cálculos de varianza, consulte el Apéndice A.</p>
<section id="momentos-muéstrales-y-estimadores-de-varianza" class="level4" data-number="2.1.4.1">
<h4 data-number="2.1.4.1" class="anchored" data-anchor-id="momentos-muéstrales-y-estimadores-de-varianza"><span class="header-section-number">2.1.4.1</span> Momentos muéstrales y estimadores de varianza</h4>
<p>Para un estadístico <span class="math inline">\(\theta\)</span>, su varianza bajo un diseño muestral <span class="math inline">\(p(s)\)</span> se define como:</p>
<p><span class="math display">\[
V(\hat{\theta}) = E((\theta - E(\hat{\theta}))^{2}) = \sum_{s \in S}{p(s)\left(\hat{\theta}_{s} - E(\hat{\theta}_{s})\right)}
\]</span></p>
<p>La forma de calcular la varianza depende del estimador <span class="math inline">\(\hat{\theta}\)</span>. Por ejemplo, para el estimador de varianza de un total, se utiliza la siguiente fórmula:</p>
<p><span class="math display">\[
V(\hat{t}_{y}) = \sum_{U}{V(I_{k} \times y_{k} \times w_{k})} + \sum_{U}{\sum_{k \not{=} l }{Cov(I_{k} \times y_{k} \times w_{k}, I_{l} \times y_{l} \times w_{l})}}
\]</span></p>
<p>Después de simplificar, obtenemos:</p>
<p><span class="math display">\[
V(\hat{t}_{y}) = \sum_{U}{V(I_{k}) \times w_{k} \times y_{k}^{2}} + \sum_{U}{\sum_{k \not{=} l }{Cov(I_{k}, I_{l}) \times y_{k} \times w_{k} \times y_{l}  \times w_{l} }}
\]</span></p>
<p>Donde definimos las siguientes identidades para simplificar cálculos:</p>
<p><span class="math display">\[
Cov(I_{k}, I_{l}) = \Delta_{kl} = \pi_{kl} - \pi_{k} \times \pi_{l}
\]</span></p>
<p><span class="math display">\[
\check{y}_{k} = y_{k} \times w_{k}
\]</span></p>
<p><span class="math display">\[
\check{\Delta}_{kl} = \Delta_{kl} \times \frac{1}{\pi_{kl}} = \Delta_{kl} \times w_{kl}
\]</span></p>
<p>Una vez definida la varianza del estimador, necesitamos estimar su varianza. Para esto, utilizamos la técnica de <span class="math inline">\(\pi\)</span>-expansión. Después de algunas manipulaciones algebraicas, obtenemos la varianza del estimador:</p>
<p><span class="math display">\[
V(\hat{t}_{y}) = \sum_{U}{\check{y}_{k}^{2}} + \sum_{U}{\sum_{k \not{=} l } \Delta_{kl} \times \check{y}_{k} \times \check{y}_{l} } = \sum_{U}{\sum{\Delta_{kl} \times \check{y}_{k} \times \check{y}_{l} }}
\]</span></p>
<p>Podemos verificar que este estimador de varianza es insesgado con las definiciones de <span class="math inline">\(E(I_{k}I_{l})\)</span> y tomando esperanzas. Es decir, se verifica que <span class="math inline">\(E(\hat{V}(\hat{t}_{y})) = V(\hat{t}_{y})\)</span>. Al ser un estimador insesgado, su eficiencia depende del diseño muestral y de la varianza de los ponderadores, es decir, de la varianza de las probabilidades de inclusión. En algunos casos, es donde entra en juego dividir grupos heterogéneos en estratos o realizar muestreos en varias etapas.</p>
<p>Para el caso de un estimador de un promedio, la varianza se define de la siguiente forma: <span class="math display">\[
V(\hat{\bar{y}}) = \frac{1}{N^{2}} \times \sum_{U}{\sum_{k \not{=} l } \Delta_{kl} \times \check{y}_{k} \times \check{y}_{l} }
\]</span></p>
<p>Esto es válido en el caso de contar con un tamaño de población conocido. En otro caso, el estimador de la media no es un estimador lineal y para calcular su varianza deben optarse por métodos de estimación de varianzas alternativos como el de linealización de Taylor.</p>
<p>Es importante considerar que en esta sección se presenta un caso ideal donde la muestra es obtenida de un listado <strong>perfecto</strong> de la población objetivo denominado <strong>marco muestral</strong>. En la práctica, el marco muestral es imperfecto y se debe considerar la no respuesta, la cobertura y la falta de actualización del marco. En general, los microdatos publicados incluyen ciertos ponderadores que no son precisamente los ponderadores originales definidos en la sección anterior, sino que son sometidos a un proceso de <strong>calibración</strong> donde se intenta ajustar a ciertas variables de control y mejorar problemas causados por la no respuesta. Al realizar el proceso de calibración, los ponderadores calibrados son lo más cercano posible a los ponderadores originales, de forma que si los ponderadores originales son insesgados, los ponderadores calibrados serán próximos a ser insesgados.</p>
<p>En la práctica, para diseños complejos no se dispone de las probabilidades de selección de segundo orden, insumo principal para calcular los errores estándar como se expuso en las formulaciones anteriores. Por esto, se requiere optar por metodologías alternativas como el método del último conglomerado, método de replicación jackknife, método de bootstrap, entre otros. En este sentido, es importante tener en cuenta que la varianza de los estimadores es un componente fundamental para realizar inferencias y cuantificar la confiabilidad de los resultados.</p>
<p>En resumen, para realizar estimaciones puntuales ya sean totales, medias, proporciones o razones, simplemente debemos ponderar los datos con los estadísticos anteriormente mencionados. Pero para realizar un proceso de inferencia completo se requiere calcular sus errores estándar, construir intervalos de confianza y/o poder medir la estabilidad de nuestros resultados. En este sentido, es importante tener al alcance herramientas que permitan realizar este tipo de cálculos, ya que en diferentes softwares estadísticos junto a la estimación puntual se presentan los errores estándar asumiendo diseños sencillos ya sea por omisión del usuario o por limitaciones de los paquetes estadísticos.</p>
<p>En base a lo expuesto en la sección anterior, es posible definir los errores estándar de los estimadores de forma teórica. Sin embargo, en la práctica, la estimación de la varianza de los estimadores es un problema complejo, especialmente en diseños de muestreo multietápicos y complejos. En estos casos, las probabilidades de inclusión de segundo orden son difíciles de calcular y se requieren métodos alternativos para estimar la varianza de los estimadores.</p>
<p>Cada estimador tiene asociado un error estándar que permite cuantificar la variabilidad de la estimación, debido a que la muestra es aleatoria esta medida es una variable aleatoria. Dentro de la incertidumbre puede separarse en errores muestrales y no muestrales. Los primeros refieren a la variabilidad de la estimación debido a la selección de la muestra y los segundos refieren a la variabilidad de la estimación debido a errores de medición, errores de no respuesta, entre otros <span class="citation" data-cites="särndal2003">(<a href="bibliography.html#ref-särndal2003" role="doc-biblioref">Särndal, Swensson, y Wretman 2003</a>)</span>.</p>
<p>En este trabajo se centra en la estimación de los errores muestrales, ya que los errores no muestrales son difíciles de cuantificar. Los errores muestrales se pueden cuantificar mediante la varianza de la estimación. Esta varianza depende del diseño muestral ya que, como se mencionó anteriormente, el diseño muestral induce propiedades estadísticas claves como la distribución en el muestreo, valores esperados y varianzas de estimadores poblacionales. El paquete <code>survey</code> permite estimar la varianza de la estimación de forma sencilla y eficiente, sin embargo, en algunos casos la estimación de la varianza no es correcta, ya que el paquete <code>survey</code> asume un muestreo simple con probabilidades de inclusión desiguales y con reposición, es decir, con una fracción de muestreo <span class="math inline">\(f = \frac{n}{N} \approx 0\)</span> <span class="citation" data-cites="lumley2004">(<a href="bibliography.html#ref-lumley2004" role="doc-biblioref">Lumley 2004</a>)</span>.</p>
<p>Para diseños multietápicos, las probabilidades de segundo orden son muy complejas de calcular, por lo que una estimación directa no es muy factible. Además, estos ponderadores no son exactamente los pesos muestrales definidos en los capítulos anteriores, ya que se ajustan para tener en cuenta la no respuesta y la calibración, lo cual permite una estimación más precisa de ciertas variables de interés. En el caso de que se cuente con un mecanismo para obtener las probabilidades de inclusión de segundo orden, este no tendría en cuenta el proceso posterior de calibración, por lo que la estimación de la varianza no sería correcta.</p>
<p>En general, para este tipo de casos se utilizan principalmente las siguientes estrategias: el método del último conglomerado, donde se asume que la variabilidad proviene únicamente de la selección en la primera etapa, y métodos de remuestreo como el Bootstrap o Jackknife. En este trabajo se propone la implementación de forma nativa de diferentes métodos utilizando solamente un argumento al cargar la encuesta, permitiendo a usuarios no expertos en metodología de muestreo obtener estimaciones de varianzas correctas y confiables.</p>
<p>Adicionalmente, para estimadores no lineales se utiliza el método de Linearización de Taylor, que permite aproximar el estimador como función de estimadores lineales. Un caso típico es la tasa de desempleo, que se calcula como el cociente entre la población desocupada y la población económicamente activa. En este caso, se puede aproximar la tasa de desempleo como función de estimadores lineales y obtener una estimación de la varianza de la tasa de desempleo o, de forma similar, un estimador de medias o proporciones.</p>
</section>
</section>
<section id="métodos-de-remuestreo" class="level3" data-number="2.1.5">
<h3 data-number="2.1.5" class="anchored" data-anchor-id="métodos-de-remuestreo"><span class="header-section-number">2.1.5</span> Métodos de remuestreo</h3>
<p>La estimación del error estándar de una media u otros resúmenes poblacionales se basa en la desviación estándar de dicho estimador a través de múltiples muestras independientes. Sin embargo, en encuestas reales solo se cuenta con una muestra. El enfoque de <strong>pesos replicados</strong> ofrece una alternativa, al calcular la variabilidad del estimador a partir de múltiples subconjuntos que se comportan de manera parcialmente independiente, y luego extrapolar esta variabilidad para obtener una estimación que se asemeje a la que se obtendría si se tuvieran múltiples muestras independientes.</p>
<section id="réplicas-de-mitad-de-muestra" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="réplicas-de-mitad-de-muestra">Réplicas de Mitad de Muestra</h4>
<p>Para entender mejor este método, se puede considerar un diseño estratificado en el que se seleccionan dos unidades por estrato. Si se dividen los datos en dos mitades, tomando una unidad de cada estrato, se crean subconjuntos que se pueden considerar como “mitades” independientes. Si la corrección por población finita no es relevante, la varianza de un estimador basado en una mitad de muestra es aproximadamente el doble de la varianza de la muestra completa. Dado que se tienen dos mitades, se puede usar la diferencia entre sus estimaciones para calcular la varianza:</p>
<p><span class="math display">\[
\text{Var}(\hat{\theta}) \approx \frac{1}{2} (\hat{\theta}_A - \hat{\theta}_B)^2,
\]</span></p>
<p>donde <span class="math inline">\(\hat{\theta}_A\)</span> y <span class="math inline">\(\hat{\theta}_B\)</span> son las estimaciones de cada mitad de la muestra. Este enfoque es sencillo pero puede ser inestable, por lo que se suelen usar múltiples conjuntos de divisiones para obtener un promedio más preciso.</p>
</section>
<section id="balanced-repeated-replication-brr" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="balanced-repeated-replication-brr">Balanced Repeated Replication (BRR)</h4>
<p>El método de <strong>Balanced Repeated Replication (BRR)</strong> es una forma sistemática de elegir subconjuntos de la muestra, garantizando que cada unidad se incluya de manera equilibrada en las réplicas. Esto se logra mediante un balanceo ortogonal, donde cada observación está presente en aproximadamente la mitad de las réplicas, y cada par de unidades de diferentes estratos aparece en las réplicas de forma equilibrada. Con (K) estratos, se puede generar un conjunto de hasta (K + 4) réplicas que produzca una estimación de la varianza que es prácticamente idéntica a la que se obtendría usando todas las (2^K) combinaciones posibles.</p>
<p>La varianza utilizando BRR se calcula así:</p>
<p><span class="math display">\[
\text{Var}_{\text{BRR}}(\hat{\theta}) = \frac{1}{R} \sum_{r=1}^R (\hat{\theta}_r - \hat{\theta})^2,
\]</span></p>
<p>donde <span class="math inline">\(R\)</span> es el número de réplicas seleccionadas y <span class="math inline">\(\hat{\theta}_r\)</span> es el estimador obtenido de cada réplica.</p>
</section>
<section id="pesos-replicados-en-diseños-multietápicos-y-complejos" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="pesos-replicados-en-diseños-multietápicos-y-complejos">Pesos Replicados en Diseños Multietápicos y Complejos</h4>
<p>El enfoque de pesos replicados no solo se aplica a diseños simples, sino que también se adapta a <strong>diseños de muestreo multietápicos</strong> y <strong>diseños complejos</strong>. En estos casos, la estructura de la muestra se complica, ya que puede involucrar varias etapas de selección (por ejemplo, seleccionar primero conglomerados como municipios, luego hogares dentro de los municipios, y finalmente personas dentro de los hogares). Esto hace que la varianza deba considerar la correlación entre unidades seleccionadas en cada etapa.</p>
<p>Para estos diseños, se utilizan métodos como el <strong>Jackknife</strong> y el <strong>Bootstrap</strong>, que permiten manejar la estructura multietápica. Por ejemplo:</p>
<ul>
<li>En un diseño <strong>Jackknife</strong>, se ajustan los pesos eliminando una observación o un conglomerado completo en cada réplica, y recalculando el estimador con los datos restantes. Esto puede ajustarse para considerar la estructura de estratos y conglomerados.</li>
</ul>
<p><span class="math display">\[
\text{Var}_{\text{Jackknife}}(\hat{\theta}) = \frac{n-1}{n} \sum_{i=1}^n (\hat{\theta}_i - \hat{\theta})^2
\]</span></p>
<p>donde (n) es el número de observaciones o conglomerados, <span class="math inline">\(\hat{\theta}_i\)</span> es la estimación obtenida cuando se omite la <span class="math inline">\(i\)</span>-ésima unidad, y <span class="math inline">\(\hat{\theta}\)</span> es la estimación con todos los datos.</p>
<ul>
<li>En el <strong>Bootstrap</strong>, se seleccionan subconjuntos con reemplazo de cada conglomerado, y se ajustan los pesos según el número de veces que cada unidad aparece en la réplica. Esto es especialmente útil cuando las unidades de muestreo tienen una estructura jerárquica, como es el caso de los diseños multietápicos.</li>
</ul>
<p><span class="math display">\[
\text{Var}_{\text{Bootstrap}}(\hat{\theta}) = \frac{1}{B} \sum_{b=1}^B (\hat{\theta}_b - \hat{\theta})^2,
\]</span></p>
<p>donde <span class="math inline">\(B\)</span> es el número de réplicas y <span class="math inline">\(\hat{\theta}_b\)</span> es el estimador obtenido en la <span class="math inline">\(b\)</span>-ésima réplica.</p>
</section>
<section id="ventajas-de-los-pesos-replicados" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="ventajas-de-los-pesos-replicados">Ventajas de los Pesos Replicados</h4>
<p>Aunque estos métodos requieren más esfuerzo computacional comparados con métodos tradicionales como el estimador de Horvitz-Thompson, son muy versátiles. Facilitan la estimación de errores estándar para diferentes tipos de estadísticas, no solo para medias o totales, y son especialmente útiles cuando se trabaja con diseños de muestreo complejos. Además, permiten obtener errores estándar precisos para estimaciones de subpoblaciones sin necesidad de ajustes adicionales. Esto los convierte en una herramienta poderosa para el análisis de encuestas complejas, especialmente con el soporte de software estadístico moderno.</p>
<p>El paquete <code>survey</code> con <code>svrep</code> proporciona una implementación robusta de varios métodos de pesos replicados, incluyendo Balanced Repeated Replication (BRR), Jackknife, y Bootstrap. Sin embargo, el uso adecuado de estos métodos a menudo no es tan conocido por usuarios que no son expertos en muestreo. La correcta especificación del diseño y la interpretación de los resultados pueden ser complejas, especialmente en el caso de diseños de muestreo multietápicos o aquellos que requieren calibración.</p>
<p>Dentro de <code>metasurvey</code> se busca simplificar el uso de estos métodos, pudiendo especificar el tipo de réplica deseado con un solo argumento al cargar la encuesta o utilizar réplicas brindadas por la institución que publica los microdatos. Además, se busca incorporar medidas de calidad de las estimaciones como el coeficiente de variación, el error relativo y el error absoluto, para facilitar la interpretación de los resultados y la comparación entre diferentes estimaciones y subpoblaciones.</p>
</section>
<section id="medidas-de-calidad-de-las-estimaciones" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="medidas-de-calidad-de-las-estimaciones">Medidas de calidad de las estimaciones</h4>
<p>Brindar medidas de calidad de las estimaciones es fundamental para evaluar la confiabilidad de los resultados y comparar diferentes estimaciones. Estas medidas permiten cuantificar la precisión de los estimadores y evaluar la variabilidad de los resultados. Algunas de las medidas más comunes son el <strong>coeficiente de variación</strong> (CV) y el <strong>efecto diseño</strong> (<em>deff</em>), ya que en algunos casos, si bien se pueden obtener estimaciones, estas pueden no ser precisas o el tamaño de la muestra en el dominio de interés puede ser pequeño, lo que puede llevar a estimaciones poco confiables.</p>
</section>
<section id="herramientas-para-la-estimación-de-varianza" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="herramientas-para-la-estimación-de-varianza">Herramientas para la estimación de varianza</h4>
<p>Si bien para una persona con experiencia en muestreo estas medidas son familiares, para un usuario no experto, en caso de no contar con herramientas que permitan calcular estas medidas, se pueden pasar por alto. En este sentido, es importante contar con herramientas que permitan calcular estas medidas de forma sencilla y eficiente, para facilitar la interpretación de los resultados y la toma de decisiones.</p>
<p>En la actualidad, existen diferentes métodos para la estimación de varianzas. Aunque en la mayoría de los casos se utilizan métodos de remuestreo como el Bootstrap o el Jackknife, existen diferentes ideas o propuestas como se menciona en <span class="citation" data-cites="deville1998">(<a href="bibliography.html#ref-deville1998" role="doc-biblioref">Deville y Tille 1998</a>)</span> y <span class="citation" data-cites="deville2005">(<a href="bibliography.html#ref-deville2005" role="doc-biblioref">Deville y Tillé 2005</a>)</span>, que demuestran con resultados numéricos que estimadores del tipo <strong>H-T</strong> bajo un diseño balanceado pueden aproximarse desde el enfoque de regresión o calibración. Además, existen estimadores alternativos que complementan métodos de remuestreo para aproximar probabilidades de inclusión de segundo orden <span class="citation" data-cites="escobar2013">(<a href="bibliography.html#ref-escobar2013" role="doc-biblioref">Escobar y Berger 2013</a>)</span> utilizando ciertas aproximaciones límites <span class="citation" data-cites="hajek1964">(<a href="bibliography.html#ref-hajek1964" role="doc-biblioref">Hajek 1964</a>)</span>.</p>
<p>En este sentido, <code>metasurvey</code> busca ser una herramienta que permita a usuarios no expertos en muestreo realizar análisis de encuestas de manera sencilla, proporcionando una interfaz amigable y herramientas que faciliten la interpretación de los resultados. Además, busca integrar diferentes métodos de estimación de varianzas y medidas de calidad de las estimaciones, para que los usuarios puedan obtener resultados confiables y precisos, sin necesidad de ser expertos en muestreo.</p>
<p>En el <a href="chapter3.html" class="quarto-xref">Capítulo&nbsp;<span>3</span></a> se presentarán conceptos relacionados al desarrollo de paquetes en R junto a la presentación de diferentes herramientas para desarrollar paquetes. Se mencionarán paquetes que permiten realizar estimaciones de varianzas y que complementarán el paquete <code>metasurvey</code> así como también paquetes similares o trabajos similares en el <a href="chapter4.html" class="quarto-xref">Capítulo&nbsp;<span>4</span></a>. En el <a href="chapter5.html" class="quarto-xref">Capítulo&nbsp;<span>5</span></a> se presentará cómo se han integrado los conceptos de muestreo y estimación de varianzas, en conjunto con las dependencias e implementaciones realizadas en el paquete <code>metasurvey</code> para facilitar el proceso de obtención de indicadores socioeconómicos y demográficos.</p>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-deville1998" class="csl-entry" role="listitem">
Deville, Jean-Claude, y Yves Tille. 1998. <span>«Unequal Probability Sampling Without Replacement Through a Splitting Method»</span>. <em>Biometrika</em> 85 (1): 89-101. <a href="https://www.jstor.org/stable/2337311">https://www.jstor.org/stable/2337311</a>.
</div>
<div id="ref-deville2005" class="csl-entry" role="listitem">
Deville, Jean-Claude, y Yves Tillé. 2005. <span>«Variance approximation under balanced sampling»</span>. <em>Journal of Statistical Planning and Inference</em> 128 (2): 569-91. <a href="https://doi.org/10.1016/j.jspi.2003.11.011">https://doi.org/10.1016/j.jspi.2003.11.011</a>.
</div>
<div id="ref-escobar2013" class="csl-entry" role="listitem">
Escobar, Emilio L., y Yves G. Berger. 2013. <span>«A new replicate variance estimator for unequal probability sampling without replacement»</span>. <em>The Canadian Journal of Statistics / La Revue Canadienne de Statistique</em> 41 (3): 508-24. <a href="https://www.jstor.org/stable/43186201">https://www.jstor.org/stable/43186201</a>.
</div>
<div id="ref-hajek1964" class="csl-entry" role="listitem">
Hajek, Jaroslav. 1964. <span>«Asymptotic Theory of Rejective Sampling with Varying Probabilities from a Finite Population»</span>. <em>The Annals of Mathematical Statistics</em> 35 (4): 1491-1523. <a href="https://doi.org/10.1214/aoms/1177700375">https://doi.org/10.1214/aoms/1177700375</a>.
</div>
<div id="ref-horvitz1952" class="csl-entry" role="listitem">
Horvitz, D. G., y D. J. Thompson. 1952. <span>«A Generalization of Sampling Without Replacement From a Finite Universe»</span>. <em>Journal of the American Statistical Association</em> 47 (260): 663-85. <a href="https://doi.org/10.2307/2280784">https://doi.org/10.2307/2280784</a>.
</div>
<div id="ref-lumley2004" class="csl-entry" role="listitem">
Lumley, Thomas. 2004. <span>«Analysis of Complex Survey Samples»</span>. <em>Journal of Statistical Software</em> 9 (abril): 1-19. <a href="https://doi.org/10.18637/jss.v009.i08">https://doi.org/10.18637/jss.v009.i08</a>.
</div>
<div id="ref-särndal2003" class="csl-entry" role="listitem">
Särndal, Carl-Erik, Bengt Swensson, y Jan Wretman. 2003. <em>Model Assisted Survey Sampling</em>. Springer Science &amp; Business Media.
</div>
</div>
</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copiado");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copiado");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/github\.com\/metaSurveyR\/metasurvey");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../chapters/chapter1.html" class="pagination-link" aria-label="Introducción">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introducción</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../chapters/chapter3.html" class="pagination-link" aria-label="Métodos computacionales">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Métodos computacionales</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/metaSurveyR/metasurvey/edit/main/chapters/chapter2.qmd" class="toc-action"><i class="bi bi-github"></i>Editar esta página</a></li><li><a href="https://github.com/metaSurveyR/metasurvey/blob/main/chapters/chapter2.qmd" class="toc-action"><i class="bi empty"></i>Ver el código</a></li><li><a href="https://github.com/metaSurveyR/metasurvey/issues/new" class="toc-action"><i class="bi empty"></i>Informar de un problema</a></li></ul></div></div></div></footer></body></html>